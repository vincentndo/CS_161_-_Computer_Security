<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
<link rel="stylesheet" type="text/css" href="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/unixwiz.css">
<link rel="shortcut icon" href="http://unixwiz.net/favicon.ico">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="http://unixwiz.net/techtips/techtips.rss">
<meta name="version" content="$Id: //websites/unixwiz/unixwiz.net/webroot/techtips/iguide-kaminsky-dns-vuln.web#9 $">
<!-- RSS description = plus many rich illustrations. -->
<!-- RSS pubDate = 2008/08/07 -->
<!-- Host: amz.unixwiz.net -->
<style type="text/css">
TABLE.standard {
	margin-bottom: 12px;
	margin-top: 12px;
}
TABLE.steps {
	border-top:    4px solid black;
	border-bottom: 4px solid black;
	margin-top:    12px;
	margin-bottom: 12px;
	margin-left:   2em;
	/* width: 95%; -- breaks IE */
	width: auto;
}
.steps TR {
	border-top: none;
}
.steps TD {
	padding-top:    8px;
	padding-bottom: 8px;
	vertical-align: top;
}
.steps TD.stepno {
	font-size: 120%;
	font-weight: bold;
	border-top: 2px solid black;
}
.steps TD.stepdesc {
	padding-left: 1em;
	border-top: 2px solid black;
}
.steps TD.stepimg {
	border-top: 2px solid black;
	padding-left: 2em;
}
#pagecontent .smallcode {
	font-size: 70%;
}
/* DNS types table */
TD.dnstype {
	font-weight: bold;
	font-size: 140%;
}
/* FAQ DL */
DL.faq DT {
	margin-top: 1em;
	font-weight: bold;
	margin-left: 0;
}
DL.faq DD {
	text-indent: -2em;
	margin-left: 2em;
}
DL.faq STRONG {
	font-weight: bold;
	font-size: 120%;
}
.codeblock B {
	color: red
}
</style>
<title>An Illustrated Guide to the Kaminsky DNS Vulnerability</title>
</head>
<body>
<div id="warning">
  <h2>Does this site look plain?</h2>
  <p>This site uses advanced css techniques</p>
</div>
<div id="logo">
 <a href="http://unixwiz.net/">
  <img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/unixwiz-logo-140x80.gif" alt="[Steve Friedl Logo]">
 </a>
</div>
<div id="pageheader">
<h1> Steve Friedl's Unixwiz.net Tech Tips </h1>
<h2> An Illustrated Guide to the Kaminsky DNS Vulnerability </h2>
</div>
<div id="navmenu">
  <ul>
<li><a href="http://unixwiz.net/"> Home </a> </li>
<li><a href="http://unixwiz.net/contact"> Contact </a> </li>
<li><a href="http://unixwiz.net/about/"> About </a> </li>
<li><a href="http://unixwiz.net/techtips/"> TechTips </a> </li>
<li><a href="http://unixwiz.net/tools/"> Tools&amp;Source </a> </li>
<li><a href="http://unixwiz.net/evo/"> Evo Payroll </a> </li>
<li><a href="http://unixwiz.net/research/"> Research </a> </li>
<li><a href="http://unixwiz.net/3b2.html"> AT&amp;T 3B2 </a> </li>
<li><a href="http://unixwiz.net/advisories.html"> Advisories </a> </li>
<li><a href="http://unixwiz.net/news.html"> News/Pubs </a> </li>
<li><a href="http://unixwiz.net/literacy.html"> Literacy </a> </li>
<li><a href="http://unixwiz.net/voting/"> Calif.Voting </a> </li>
<li><a href="http://unixwiz.net/personal/"> Personal </a> </li>
<li><a href="http://blog.unixwiz.net/"> Tech Blog </a> </li>
<li><a href="http://hikeblog.unixwiz.net/"> Hiking Blog </a> </li>
<li><a href="http://smokeblog.unixwiz.net/"> SmokeBlog </a> </li>
</ul>
</div>
<div id="pagecontent">

<a href="http://doxpara.com/">
<img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/dan-kaminsky.gif" alt="Dan Kaminsky - guilty grin" class="floatRightTop" width="154" height="233">
</a>

<p>
The big security news of Summer 2008 has been <a href="http://www.doxpara.com/">Dan
Kaminsky's</a> discovery of a <a href="http://www.kb.cert.org/vuls/id/800113">serious
vulnerability in DNS</a>. This vulnerability could allow an attacker to redirect
network clients to alternate servers of his own choosing, presumably for ill ends.
</p>


<div id="toc">
<center> Table of Contents </center>
<ul>
<li> <a href="#terms"> Terminology </a> </li>
<li> <a href="#simple"> Following a simple DNS query </a> </li>
<li> <a href="#packet"> What's in a DNS packet? </a> </li>
<li> <a href="#types"> Resource Record Types </a> </li>
<li> <a href="#drilldown"> Drilling down to a real query </a> </li>
<li> <a href="#cache"> What's in the cache? </a> </li>
<li> <a href="#poisoning"> Poisoning the cache </a> </li>
<li> <a href="#shenanigansv1"> Shenanigans, Version 1 </a> </li>
<li> <a href="#shenanigansv2"> Dan's Shenanigans </a> </li>
<li> <a href="#fix"> What's the fix? </a> </li>
<li> <a href="#summary"> Summary </a> </li>
<li> <a href="#refs"> Other References </a> </li>
</ul>
</div>

<p>
This all led to a mad dash to patch DNS servers worldwide, and though there have
been many writeups of just how the vulnerability manifests itself, we felt the need
for one in far more detail. Hence, one of our Illustrated Guides.
</p>

<p>
This paper covers how DNS works: first at a high level, then by picking
apart an individual packet exchange field by field. Next, we'll use this knowledge
to see how weaknesses in common implementations can lead to cache poisoning.
</p>

<p>
By fully understanding the issues at play, the reader may be better equipped
to mitigate the risks in his or her own environment.
</p>

<p>
We hope everybody who runs a DNS server patches soon.
</p>

<br clear="all">

<h1 id="terms"> Terminology </h1>

<p>
Before we see how DNS operates, we need to define a few terms to know
who the players are, software-wise. This will be review for many, and
in some cases we leave out side details that an expert would find
fault with. Omitted details won't matter for an understanding of this
issue.
</p>

<dl class="defnlist">

<dt> zone </dt>
<dd>

	Think of this as a "domain": a collection of hostnames/IP pairs
	all managed together.
</dd>

<dd>
	Our servers operate <b>unixwiz.net</b>, and all the DNS records that
	go with it — <b>www.unixwiz.net</b>, <b>mvp.unixwiz.net</b>,
	<b>cs.unixwiz.net</b>, etc. — are all part of the <b>unixwiz.net</b> zone.
</dd>

<dd>
The subtle distinction comes with subdomains: sometimes they are part
of the main zone, sometimes they are a separate zone, but none of that
matters for this paper.
</dd>

<dt> Nameserver </dt>
<dd>
This is server software that answers DNS questions, such as "What is the
IP address for www.unixwiz.net?". Sometimes a nameserver knows the answer
directly (if it's "authoritative" for the zone), other times it has to
go out to the internet and ask around to find the answer (if it's a recursive
nameserver).
</dd>

<dd>
There is wide variety of software that performs this service:
<a href="http://www.isc.org/sw/bind/">BIND</a>,
<a href="http://www.powerdns.com/">PowerDNS</a>,
<a href="http://cr.yp.to/djbdns.html">djbdns</a>,
and many others. They all answer the same questions more or less
the same way, though the minor differences matter some for this paper.
</dd>

<dt> Authoritative Nameserver </dt>
<dd>
For every zone, <i>somebody</i> has to maintain a file of the hostnames and
IP address associations ("linux.unixwiz.net is 64.170.162.98", and so on).
This is generally an administrative function performed by a human, and in
most cases <b>one</b> machine has this file. It's the zone master.
</dd>
<dd>
Zones with multiple public nameservers make administrative
arrangements to transfer the zone data automatically to additional slave
nameservers, all of which are authoritative as far as the outside world is concerned.
The distinction between master and slave is unimportant for this paper.
</dd>

<dt> Resolver </dt>
<dd> This is the client part of the DNS client/server system: it <b>asks the questions</b>
about hostnames. The resolver is usually a small library compiled into
each program that requires DNS services, and it knows just enough to send questions
to a nearby nameserver.
</dd>
<dd>
On Linux/UNIX systems, the location of the servers-to-ask is found in the file
<b>/etc/resolv.conf</b>, and on Windows it's part of the Network Connections setup
in the control panel. This usually consists of a list of IP addresses, each of
which expects to find a nameserver on the other end.
</dd>

<dd>
Resolvers are usually very small and dumb, relying on the servers to do the
heavy lifting.
</dd>

<dt> Recursive Nameserver </dt>
<dd> This is a nameserver that's willing to go out on the internet and find
the results for zones it's not authoritative for, as a service to its clients.
Not all nameservers are configured to provide recursive service, or are limited
to just trusted clients (say, an ISP may provide nameservice only to its
customers).
</dd>

<dt> Resource Record </dt>
<dd> Though most think of DNS as providing hostname-to-IP mapping, there are
actually other kinds of questions we can ask of a nameserver, and this highlights
the notion that DNS is really a database of "resource records".
</dd>
<dd>
The most common type is an IP Address (an "A" record), but other records
exist too: NS (nameserver), MX (mail exchanger), SOA (Start of Authority),
and so on.
</dd>

<dt> Delegation </dt>
<dd>
When a nameserver doesn't have the contents of a zone, but knows how to
find the owner, it's said to <b>delegate</b> service of that zone to another
nameserver. Informally, it's a pass-the-buck mechanism: "I know the zone
you're asking about, go ask (hostname) for the details".
</dd>

</dl>

<h1 id="simple"> Following a simple DNS query </h1>

<img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/dns-lookup-logo.gif" alt="DNS query logo - ping" class="floatRightTop" width="375" height="151">

<p>
With a few key terms defined, we'll review how a simple recursive query works
in the absence of any bugs or shenanigans; this forms the background of where
the exploits can later be applied.
</p>

<p>
Though the DNS packet itself has many fields (each of which is important), we're
omitting that detail for now in order to understand the high level flow of a full
query, from top to bottom. Visualizing how delegation bounces requests from one
server to another is vital to understanding the vulnerability will be exploited later.
</p>

<p>
We can't really tell by looking at the query itself what prompted the query
in the first place.  In the logo of this section, we see that the user attempted
to ping our webserver, and the <b>ping</b> program asked the nameserver to perform
this name-to-IP lookup.
</p>

<p>
But it could have just as easily been a user entering <b>http://www.unixwiz.net</b>
in a browser address bar. But it's not important to know <b>why</b> the name's being
looked up, only to know <b>how</b> it looks up.
</p>

<table class="steps">
<tbody><tr>
 <td class="stepno"> 1 </td>
 <td class="stepdesc">
  <p>
   The client (noted as "User's PC") makes a request for <b>www.unixwiz.net</b>,
   and it's routed to the nameserver provided by the user's ISP. It requests
   the <b>A record</b>, which represents an IP address.
  </p>
  <p>
   The ISP's nameserver knows that it's not authoritative for <b>unixwiz.net</b>,
   so it can't look it up in its local zone database. It also doesn't find the
   name it its cache of recently-seen data, so it knows it has to go out to the
   internet to find it for us.
  </p>
 </td>
 <td class="stepimg">
	<img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/typical-dns-resolution-1.gif" alt="DNS resolution, step 1" width="250" height="208">
 </td>
</tr>

<tr>
 <td class="stepno"> 2 </td>
 <td class="stepdesc">
  <p>
    All recursive nameservers are preconfigured with a list of 13 root
    servers, a selection of which looks like:
  </p>
  <div class="blocklabel">Root hints</div>
  <pre class="codeblock smallcode">A.ROOT-SERVERS.NET.  IN  A  198.41.0.4
B.ROOT-SERVERS.NET.  IN  A  192.228.79.201
C.ROOT-SERVERS.NET.  IN  A  192.33.4.12
...
M.ROOT-SERVERS.NET.  IN  A  202.12.27.33
</pre>
<p>
Thankfully these IP addresses don't change very often.
</p>
<p>
The nameserver picks one at random and sends off the query for
the A record of <b>www.unixwiz.net</b>; here it's going to <b>b.root-servers.net</b>
</p>
 </td>
 <td class="stepimg" rowspan="2">
	<img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/typical-dns-resolution-23.gif" alt="DNS resolution, steps 2 and 3" width="500" height="478">
 </td>

</tr>

<tr>
  <td class="stepno"> 3 </td>
  <td class="stepdesc">
<p>
The root server doesn't know anything about <b>unixwiz.net</b>, but is happy
to send me the way of the Global Top Level Domain (GTLD) servers responsible
for the <b>.net</b> domain. This is in the form of <b>NS</b> records of servers
more qualified to answer our query: "Go ask these guys - here's a list".
</p>
<div class="blocklabel">.NET referrals</div>
<pre class="codeblock smallcode">/* <b>Authority section</b> */
NET.                 IN  NS A.GTLD-SERVERS.NET.
                     IN  NS B.GTLD-SERVERS.NET.
                     IN  NS C.GTLD-SERVERS.NET.
                     ...
                     IN  NS M.GTLD-SERVERS.NET.

/* <b>Additional section - "glue" records</b> */
A.GTLD-SERVERS.net.  IN  A  192.5.6.30
B.GTLD-SERVERS.net.  IN  A  192.33.14.30
C.GTLD-SERVERS.net.  IN  A  192.26.92.30
...
M.GTLD-SERVERS.net.  IN  A  192.55.83.30
</pre>
<p>
Though technically we asked only for the <b>NS</b> records, the root
servers also give us the IP address of each: this is known as "glue"
and is provided to save us from having to look it up.
</p>
</td>

</tr>

<tr>
 <td class="stepno"> 4 </td>
 <td class="stepdesc">
With the helpful referral from the root servers, this nameserver chooses one of the
authoritative servers at random — here, <b>c.gtld-servers.net</b> — and
sends off the same query: "I was told to ask you: what's the A record for <b>www.unixwiz.net</b>?".
 </td>
 <td class="stepimg" rowspan="2">
 <img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/typical-dns-resolution-45.gif" alt="DNS Resolution, steps 5 and 6" width="500" height="478">
 </td>
</tr>

<tr>
 <td class="stepno"> 5 </td>
 <td class="stepdesc">
<p>
The GTLD server doesn't know the specific answer to our query, but it does
know how to get us closer. Like the root servers, it sends back a referral
(a set of <b>NS</b> records) that are likely to have what we seek.
</p>

<div class="blocklabel">unixwiz.net referral</div>
<pre class="codeblock smallcode">/* <b>Authority section</b> */
unixwiz.net.        IN  NS cs.unixwiz.net.
                    IN  NS linux.unixwiz.net.

/* <b>Additional section</b> - "glue" records */
cs.unixwiz.net.     IN  A  8.7.25.94
linux.unixwiz.net.  IN  A  64.170.162.98
</pre>

</td>
</tr>

<tr>
 <td class="stepno"> 6 </td>
 <td class="stepdesc">
Once again the recursive nameserver is following a chain of referrals on the
client's behalf, and it picks one of the nameservers at random and sends off
a third query (the same as the other two).
 </td>
 <td class="stepimg" rowspan="2">
  <img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/typical-dns-resolution-67.gif" alt="DNS resolution, steps 7 and 7" width="500" height="478">
 </td>
</tr>

<tr>
 <td class="stepno"> 7 </td>
 <td class="stepdesc">
<p>
Unlike the other answers, that merely passed the buck onto other nameservers,
<b>this</b> one actually has what we were looking for: it provides the <b>A record</b>
for <b>www.unixwiz.net</b>.
</p>
<p>
In addition, the response includes a flag saying "This is an authoritative response",
indicating it came from the source of truth for this domain.
</p>

 </td>
</tr>

<tr>
 <td class="stepno"> 8 </td>
 <td class="stepdesc">
<p>
Now with answer in hand, the ISP's recursive nameserver hands that answer
back to the client, and that satisfies the entire query.
</p>

<p>
The recursive nameserver also files away this answer into its own cache
in case this or some other client makes the same query later.
</p>

<p>
But we'll note that the reply to the client doesn't include the
"authoritative" indicator. Even though it received one from
cs.unixwiz.net, the recursive nameserver can't pretend to the
client that it's actually the source of authority, so it's
considered a non-authoritative answer.
</p>
</td>
 <td class="stepimg">
  <img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/typical-dns-resolution-8.gif" alt="DNS resolution, steps 7 and 7" width="500" height="478">
 </td>
</tr>

</tbody></table>

<p>
This procedure goes on under the hood trillions of time every day over the
internet. DNS is quite fast, so the eight-packet handshake (for this particular
query) routinely completes in just a split second.
</p>

<p>
This reveals the distributed nature of DNS: no one machine knows everything,
but they do know how to find each other via delegation.
</p>

<p>
As a side note, nothing prevents any nameserver from hosting any zone, including
those it doesn't really own. A bad guy could set up a nameserver and configure
an authoritative zone for <b>BankOfSteve.com</b>, but it has no effect because
no higher-level nameserver ever delegates to it.
</p>


<h1 id="packet"> What's in a DNS packet? </h1>

<p>
With a grasp of the high-level exchanges we dig a bit deeper into what's
inside a DNS packet: the details are required to understand cache poisoning
and this recent vulnerability. There's a lot of detail here, but fortunately
many of the fields aren't important for an understanding of these issues.
</p>

<p>
The illustration on the right shows the overall structure of a single packet
of DNS data, and it can reflect a question packet or an answer packet. We've
highlighted some of the fields that are most related to this exploit.
</p>

<img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/dns-query-packet.gif" alt="regular DNS packet" class="floatRightTop" width="426" height="438">

<dl class="defnlist">

<dt> Source / Destination IP address </dt>
<dd> These reflect the IP addresses of the machines that sent and
should receive the packet. It's possible to <b>forge</b> the source
address, but pointless to forge the destination.
</dd>

<dd>
Analog in the real world: on an envelope sent in the US Mail, you can put
anything you want as the <u>return address</u> — the source address —
but if you lie about the <u>recipient</u>, it's not going to go where you want.
</dd>

<dt> Source / Destination port numbers </dt>
<dd>
DNS servers listen on port 53/udp for queries from the outside world,
so the first packet of any exchange always includes 53 as the UDP destination
port.
</dd>
<dd>
The source port varies considerably (though not enough, as we'll find
shortly): sometimes it's also port 53/udp, sometimes it's a fixed port chosen
at random by the operating system, and sometimes it's just a random port
that changes every time.
</dd>
<dd>
As far as DNS functionality is concerned, the source port doesn't really matter
as long as the replies get routed to it properly. But this turns out to be
the crux of the problem at hand.
</dd>

<dt> Query ID </dt>
<dd> This is a unique identifier created in the query packet that's left
intact by the server sending the reply: it allows the server making the
request to associate the answer with the question.
</dd>
<dd>
A nameserver might have many queries outstanding at one time — even multiple
queries to the <u>same</u> server — so this Query ID helps match the answers
with the awaiting questions.
</dd>

<dd>
This is also sometimes called the Transaction ID (TXID).
</dd>

<dt> QR (Query / Response) </dt>
<dd>
Set to <b>0</b> for a query by a client, <b>1</b> for a response from a server.
</dd>

<dt> Opcode </dt>
<dd> Set by client to <b>0</b> for a standard query; the other types
aren't used in our examples. </dd>

<dt> AA (Authoritative Answer) </dt>
<dd> Set to <b>1</b> in a server response if this answer is Authoritative, <b>0</b> if not. </dd>

<dt> TC (Truncated) </dt>
<dd> Set to <b>1</b> in a server response if the answer can't fit in the 512-byte limit of
a UDP packet response; this means the client will need to try again with a TCP query,
which doesn't have the same limits.
</dd>

<dt> RD (Recursion Desired) </dt>
<dd> The client sets this to <b>1</b> if it wishes that the server will perform the
entire lookup of the name recursively, or <b>0</b> if it just wants the best information
the server has and the client will continue with the iterative query on its own. Not all
nameservers will honor a recursive request (root servers, for instance, won't ever perform
recursive queries).
</dd>

<dt> RA (Recursion Available) </dt>
<dd> The server sets this to indicate that it will (<b>1</b>) or won't (<b>0</b>)
support recursion.
</dd>

<dt> Z — reserved </dt>
<dd> This is reserved and must be zero </dd>

<dt> rcode </dt>
<dd> Response code from the server: indicates success or failure </dd>

<dt> Question record count </dt>
<dd>
The client fills in the next section with a single "question" record that specifies
what it's looking for: it includes the name (<b>www.unixwiz.net</b>), the type
(<b>A</b>, <b>NS</b>, <b>MX</b>, etc.), and the class (virtually always
<b>IN</b>=Internet).
</dd>

<dd>
The server repeats the question in the response packet, so the question count is
almost always <b>1</b>.
</dd>

<dt> Answer/authority/additional record count </dt>
<dd>
Set by the server, these provide various kinds of answers to the query
from the client: we'll dig into these answers shortly.
</dd>

<dt> DNS Question/Answer data </dt>
<dd>
This is the area that holds the question/answer data referenced by the count
fields above. These will be discussed in great detail later.
</dd>

</dl>

<p>
We'll see these in action as we disassemble our sample query shortly.
</p>

<h1 id="types"> Resource Record Types </h1>


<a href="http://www.dns.net/dnsrd/rr.html">
<img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/dns-types-logo.gif" alt="DNS Types logo" class="floatRightTop" width="250" height="197">
</a>

<p>
Ultimately, DNS is a kind of distributed database, and each query or response
includes a name, a type, and (for a response) a value. The resource types
represent different purposes, and no understanding of DNS is complete without
knowing about them.
</p>

<p>
There are dozens of resource record types, though only a few are in common
usage. The rest are experimental, obsolete, or serve obscure purposes that
rarely come up in practice.
</p>

<table class="standard">
 <caption> Common DNS Resource Record Types </caption>

 <thead>
   <tr>
     <th> Type </th>
     <th> Description </th>
   </tr>
 </thead>

 <tbody>
   <tr>
     <td class="dnstype"> A </td>
     <td class="dnsdesc">
  	This is an <b>IP Address</b> record, and is the most obvious type
  	of data supported by DNS.  Indeed; many users have no idea that
    	DNS deals with anything <u>other</u> than IP addresses.
     </td>
   </tr>

   <tr>
     <td class="dnstype"> NS </td>
     <td class="dnsdesc">
  	This describes a <b>Nameserver</b> record responsible for the domain
  	asked about.
     </td>
   </tr>

   <tr>
     <td class="dnstype"> MX </td>
     <td class="dnsdesc">
	<p>
	The MX record encodes the name of a <b>Mail Exchanger</b>, a system
	responsible for handling email for the given domain. Multiple MX
	records can be provided for a domain (they included way to specify
	priority). Email server software is the main consumer of <b>MX</b>
	resource records.
	</p>

	<p>
	Curiously, the mail exchanger for a domain doesn't have to be
	<u>part</u> of that domain; it's common for the mailserver at
	a large hosting operation to be primary MX for thousands of
	customer domains.
	</p>
     </td>
   </tr>

   <tr>
     <td class="dnstype"> SOA </td>
     <td class="dnsdesc">
  	The <b>Start of Authorities</b> record describes some key data about the
  	zone as defined by the zone administrator (on the domain master machine).
	It includes things such as the contact address for the admin, and the
	amount of time that slave nameservers should hang onto the zone in case
	the master is unreachable.
     </td>
   </tr>

   <tr>
     <td class="dnstype"> CNAME </td>
     <td class="dnsdesc">
  	The <b>Canonical Name</b>, more commonly known as an <b>Alias</b>, this
  	allows providing an alternate name for a resource.
     </td>
   </tr>

   <tr>
     <td class="dnstype"> TXT </td>
     <td class="dnsdesc">
  	A generic <b>Text</b> record that provides descriptive data about
  	domain. These are essentially comments, though some applications
	(such as <a href="http://www.openspf.org/">SPF</a>) use them for
	programmatic purposes.
     </td>
   </tr>
 </tbody>
</table>

<p>
It's generally (but not universally) allowed that one name can have multiple resource records,
even more than one of the same type. A common example would be a machine
having multiple IP addresses, both of which are entered in DNS:
</p>

<pre class="codeblock">www.example.com. IN A <b>192.168.1.3</b>
www.example.com. IN A <b>192.168.7.149</b>
</pre>

<p>
Here, the name <b>www.example.com</b> has two IP address records associated
with it, and both will be returned in answer to an <b>A</b> query
for this name. Note that the order of the addresses as they appear in
the file are not maintained in the responses: they're usually shuffled.
</p>

<p>
We'll note that the <b>IN</b> token means the <b><u>IN</u>ternet</b> class, and this
is virtually the only class you'll ever see in practice. Others (such as
Chaos or Hesiod) are defined but are for specialized and mostly obsolete
purposes.
</p>

<h1 id="drilldown"> Drilling down to a real query </h1>

<img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/dns-4packets-logo.gif" alt="Steps 4..7" class="floatRightTop" width="154" height="80">

<p>
Recalling our query exchange above, we're going to study steps 4 through 7 in
some detail: they are most representative of the DNS name-resolution process
without adding duplicative steps.
</p>

<p>
Ultimately, DNS is a kind of distributed database, and it can look up much
more than just an IP address: there are multiple <b>resource record</b> types
involved in a query, and one can't understand the packet structure without
knowing their distinctions.
</p>

<p>
We'll note that not <u>every</u> detail is predictable even when the protocol
is fully understood: nameservers have some latitude in how they accomplish a
resolution, so a few alternatives are available. We're just choosing one common
path through this process.
</p>

<p>
In this example, we're using the nameserver of our own ISP — <b>dnsr1.sbcglobal.net</b>
— (referred to as <b>dnsr1</b>) as the local recursive nameserver, and we'll
find a few things in common for all of them.
</p>

<div class="sidebar">
<center> Contrived Data! </center>
<p>
In this example we're showing a hypothetical packet trace for our own ISP's
recursive nameserver, but this is a <b>made-up example</b>.
</p>

<p>
We certainly have no way to actually sniff the real traffic coming and
going from <b>their</b> server, but we'll note that as of this writing,
AT&amp;T had patched this server to avoid this vulnerability.
</p>
</div>

<ul>
<li> In every case, the Question section is the same: "What is the A
record for <b>www.unixwiz.net</b>?". This question is also repeated
in the answer — mainly as a convenience — so it's seen in
common in every packet we look at.
</li>

<li> The ISP's nameserver usually sets the <b>RD=1</b> flag (Recursion Desired) on the
odd chance that the other end is willing to do the heavy lifting and go find
this answer for us. Most top-level nameservers are unwilling to do this, so they
give us the best information they have and set <b>RA=0</b> flag (Recursion Unavailable)
to let us know that we have to do the work ourselves.
</li>

<li> In this example, the source UDP port number for all queries from
our ISP's nameserver is the same. It's a common practice for nameserver
software to request a random port from the operating system at startup,
then use it for every query.
</li>

<li> We observe that the Query ID increments by one each time it sends
a new query.
</li>

</ul>

<p>
So with this information in hand, let's walk through the steps in detail and
see how our "simple" query is actually resolved.
</p>

<table class="steps">
  <tbody><tr>
    <td class="stepno"> 2&amp;3 </td>
    <td class="stepdesc">
	In this step our ISP's nameserver queried a root
	server for <b>www.unixwiz.net</b>, and it replied with a list of
	global top-level domain servers that knew about the <b>.net</b> hierarchy.
	From this delegation, the ISP's nameserver chose one at random
	(<b>c.gtld-servers.net</b>), as shown in step 4.
    </td>
    <td class="stepimg"> (not illustrated) </td>
  </tr>

  <tr>
    <td class="stepno"> 4 <br> <small> client to server </small> </td>
    <td class="stepdesc">
	<p>
	The <b>dnsr1</b> server at our ISP grabs one of the GTLD nameservers
	received from a root server (in step 3) and fires off a second query.
	This is essentially the same as the first; the Question is about the
	<b>A record</b> www.unixwiz.net.
	</p>

	<p>
	Because this is a <b>query</b> — not a <b>response</b> —
	the answer/authorities/additional records fields are blank (as shown
	with a count of zero).
	</p>

	<p>
	The <b>Query ID</b> value was taken as the next ID available from
	this server's internal counter.
	</p>
    </td>
    <td class="stepimg">
	<img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/dns-packet-exchange-step4.gif" alt="DNS Packet, Step 4" width="557" height="328">
    </td>
  </tr>

  <tr>
    <td class="stepno"> 5 <br> <small> server to client </small> </td>
    <td class="stepdesc">
	<p>
	The GTLD server we asked doesn't know the specific answer to our
	question, but it knows where to ask: it responds with a series
	of <b>NS</b> records that should know how to handle our request.
	They show up in the Authorities section as <b>cs.unixwiz.net</b> and
	<b>linux.unixwiz.net</b>.
	</p>

	<p>
	We're given <u>hostnames</u> of the nameservers we ought to contact,
	but real network connections are only made by IP address: how do we
	look these up? Avoiding what would clearly be a chicken-and-egg
	problem, the GTLD nameserver provides not only the hostnames of
	the authoritative servers, but <b>their IP addresses too</b>.
	</p>

	<p>
	These are provided as <b>A</b> records in the "Additional Records"
	section, and are known as "glue data".
	</p>

	<p>
	Because this nameserver can't give us the final answer, it sets
	the <b>AA=0</b> flag (Authoritative Answer) to zero, indicating
	that somebody else knows the real story and we have to keep
	asking around.
	</p>

	<p>
	But a related note: <b>dnsr1</b> is a very busy nameserver, having
	perhaps hundreds of queries outstanding every second. How does it
	know that <u>this</u> reply packet is a response to that specific
	pending request?
	</p>

	<p>
	The answer is: by matching on the <b>Query ID</b>.
	Inbound DNS packets that don't have a waiting Query ID are
	ignored.
	</p>

	<p>
	The TTL is a <b>Time To Live</b>, discussed later.
	</p>
    </td>
    <td class="stepimg">
	<img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/dns-packet-exchange-step5.gif" alt="DNS Packet, Step 5" width="557" height="463">
    </td>
  </tr>

  <tr>
    <td class="stepno"> 6 <br> <small> client to server </small> </td>
    <td class="stepdesc">
	<p>
	In step 5 we received two nameservers that are purported to know more
	about the <b>unixwiz.net</b> domain, so one more query is created
	that asks the same question — again! — of these just-learned
	nameservers.
	</p>

	<p>
	This request is really no different from the previous queries, though
	it does increment the Query ID by one before sending it off. The idea
	is that we keep following these delegations until we actually get a
	<b>real</b> answer, not a referral.
	</p>
    </td>
    <td class="stepimg">
	<img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/dns-packet-exchange-step6.gif" alt="DNS Packet, Step 6" width="557" height="328">
    </td>
  </tr>

  <tr>
    <td class="stepno"> 7 <br> <small> server to client </small> </td>
    <td class="stepdesc">
	<p>
	And at last the answer comes!
	</p>

	<p>Unlike the previous replies, this
	one has <b>answer count=1</b>, and it carries an <b>A record</b>
	with the IP address to satisfy our query.
	</p>

	<p>
	In addition, this response has the <b>AA=1</b> flag set, which indicates
	that it's an <b>authoritative</b> answer (aka "from the horse's mouth").
	If an answer is provided but with AA=0, we assume it's from the server's
	cache.
	</p>

	<p>
	The answer also includes the authority and glue information, but this time
	all we're really interested in is the answer itself. And the nameserver
	used the Query ID of <b>43562</b> to match this reply to the pending request.
	</p>

	<p>
	</p>
    </td>
    <td class="stepimg">
	<img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/dns-packet-exchange-step7.gif" alt="DNS Packet, Step 7" width="557" height="463">
    </td>
  </tr>
</tbody></table>

<p>
As noted previously, these transactions typically occur <b>very</b> rapidly
across the internet, and the user is normally unaware that so much is going
on under the hood on his behalf.
</p>

<p>
But local performance is further enhanced by use of a local <b>cache</b>
in the recursive nameservers: this is an important part of the domain-name
system, and gets us one step closer to our security issue.
</p>

<h1 id="cache"> What's in the cache? </h1>

<img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/dns-cash.gif" alt="Dollar bill: yes, it's a visual pun" class="floatRightTop" width="264" height="115">

<p>
In the DNS lookups we've seen so far, the ISP's resolving nameserver has
gone out and fully resolved each name from scratch, relying on no prior
knowledge except the built-in root hints.
</p>

<p>
But in practice this full road trip is not necessary: once we get an
authoritative answer for a given name, we can save it in a local cache
to use to satisfy future queries directly.
</p>

<p>
The more clients serviced by a nameserver, the more benefit of the cache:
the work of the full name resolutions is spread out over the whole client
base. It may well require quite a bit of memory in the nameserver, but the
amounts of RAM required are peanuts compared with the benefits.
</p>

<img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/dns-ttl-logo.gif" alt="TTL logo - stopwatch" class="floatLeft" width="71" height="88">

<h2 id="ttl"> The Time-To-Live </h2>


<p>
When a DNS answer is stored in the local cache, it can't keep it forever:
this could lead to terribly stale data that effectively breaks the domains
involved.
</p>

<img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/dns-packet-ttl-a.gif" alt="subset of packet showing A record TTL" class="floatRightTop" width="298" height="76">

<p>
Fortunately, the recursive nameserver doesn't have the burden of guessing
how long to cache things: the <b>administrator of the zone</b> specifies
this information for every resource record. This is known as a <b>Time To Live</b>
(TTL), and it's a lifetime measured in seconds.
</p>


<p>
A TTL can be a short as a few minutes, or as long as a week
or more: this is entirely determined by the administrator of the zone.
</p>

<p>
In our final Step-7 answer above (with snippet to the right), we see the TTL of one hour
for the <b>A</b> record in <b>www.unixwiz.net</b>. All client requests for this
resource record in the next hour will be satisfied immediately, from the
cache. But once it expires, it's removed from cache and the next request
will force a full lookup from scratch.
</p>

<img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/dns-packet-ttl-ns.gif" alt="subset of packet showing NS/glue TTL" class="floatRightTop" width="298" height="135">

<p>
But it's not just the <b>A</b> record that's cached; all the other authority
data (the <b>NS</b> data plus associated glue <b>A</b> records) arrive with
their own TTLs, and are also cached. This means that a full lookup for
a single resource record could well fill the cache with a half
dozen associated records or more.
</p>



<br clear="all">

<h1 id="poisoning"> Poisoning the cache </h1>

<!-- icon here? -->

<p>
With a good understanding of a properly-functioning DNS, it's time to see
where things break. <b>Cache poisoning</b> is where the bad guy manages to
inject bogus data into a recursive nameserver's cache, causing it to give
out that bad information to unsuspecting local clients.
</p>

<p>
It's not so simple as just sending random DNS packets to a nameserver, as
DNS only accepts <b>responses to pending queries</b>; unexpected responses
are simply ignored.
</p>

<div class="sidebar">
<center> This is not "phishing" </center>

<p>
Though DNS cache poisoning has similar end results to phishing
— getting a user to believe a bad site is genuine —
it's not the same thing.
</p>

<p>
With <b>phishing</b>, a bogus URL is used to reference the
malicious server, but it's disguised to look like the real hostname
(usually with a bit of clever HTML or CSS). An attentive user can
usually detect this misdirection by examining the URLs or hostnames
carefully.
</p>

<p>
With <b>DNS cache poisoning</b>, the very nature of DNS itself has
been subverted such that hostname-to-IP lookups can no longer be
trusted. The hostnames being visited are genuine, but they're
being routed to the bad server: this can't be detected by
inspection of links or HTML source code.
</p>

</div>

<p>
How does a nameserver know that any response packet is "expected"?
</p>

<ul>
<li>
	The response arrives on the same UDP port we sent it from:
	otherwise the network stack would not deliver it to the waiting
	nameserver process (it's dropped instead).
</li>

<li>
	The <b>Question</b> section (which is duplicated in the reply)
	matches the Question in the pending query.
</li>

<li>
	The <b>Query ID</b> matches the pending query
</li>

<li> <p>
	The Authority and Additional sections represent names that
	are within the same domain as the question: this is known
	as "bailiwick checking".
	</p>
	<p>
	This prevents <b>ns.unixwiz.net</b>
	from replying with not only the IP address of <b>www.unixwiz.net</b>,
	but also fraudulent information about (say) <b>BankOfSteve.com</b>.
	</p>
</li>

</ul>

<p>
If all of these conditions are satisfied, a nameserver will accept a packet
as a genuine response to a query, and use the results found inside. This
includes caching answers, as well as valid authority and additional data found
there too.
</p>

<p>
But if the bad guy can predict and forge a DNS response packet that's
<i>just right</i>, he can cause all kinds of shenanigans for the
victims.
</p>

<p>
The bad guy normally first chooses his <b>victim</b> by finding a nameserver
he believes vulnerable to poisoning: all of the clients of that DNS server get
to unwittingly ride the victim train as well.
</p>

<p>
Then he finds a <b>target domain</b>, one he wishes to take over. His intent
is to fool the victims into visiting his own malicious website instead of
the real deal: by getting <b>www.goodsite.com</b> to resolve to the <b>bad guy's
IP address</b>, the user's traffic visits the bad guy's website instead of
the good one.
</p>

<p>
We noted that unexpected packets were simply dropped, so a bad guy need not
get everything right every time: sending many packets attempting to guess some
of the key parameters is likely to prove fruitful with enough attempts.
</p>

<h2 id="guessqid"> Guessing the Query ID </h2>

<p>
In old nameservers (and in our detailed packet trace example), the Query ID
simply increments by one on each outgoing request, and this makes it easy to
guess what the next one will be as long as an interloper can see a single
query.
</p>

<img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/badguy-intercept-dns.gif" alt="Bad guy finding Query ID" class="floatRightTop" width="499" height="492">

<p>
We probably can't directly ask the nameserver for its query ID, but we can
provoke it into telling us:
</p>

<ol>
<li>
     <p> Bad guy asks the victim nameserver to look up a name in a zone for
     a nameserver he controls (perhaps <b>test.badguy.com</b>).
     </p>


     <p>
     He might query the server directly, if it permits recursion from
     his location, or he might convince a user to lookup a name —
     perhaps by including the test hostname on a web page.
     </p>
</li>
<li> Victim nameserver receives the request and makes the usual rounds
     to resolve the name starting at the root servers. Here, we've put
     the root and GTLD servers in the same category to separate them
     from the bad guy's nameserver.
</li>

<li> Eventually, the victim nameserver will be directed to the bad guy's
     nameserver: after all, it's authoritative for <b>badguy.com</b>.
</li>

<li>
  <p> Bad guy monitors this lookup of <b>test.badguy.com</b> by
      sniffing the IP traffic going to his own machine, or perhaps
      even with a custom modification to the nameserver software,
      and from this discovers the source port and Query ID used.
  </p>

  <p>
      <b>Aha!</b>
  </p>
</li>

</ol>

<p>
At this point he knows the last query ID and source port used by
the victim nameserver.
</p>

<p>
But the thoughtful might wonder: so what? This hasn't poisoned anything
yet, and there's no need to engage in DNS shenanigans for <b>badguy.com</b>
anyway. After all, the bad guy is already authoritative for his own zone.
</p>

<p>
True enough, but this was only the first step: the <i>next</i> one
engages in DNS shenanigans for <u>other</u> domains.
</p>

<h1 id="shenanigansv1"> Shenanigans, Version 1 </h1>

<p>
With the ability to easily predict a query ID, and since our
victim nameserver always sends queries from the same UDP port,
it should be easy enough to cause some trouble.
</p>

<p>
In this illustration, we'll attempt to poison a particular
nameserver with a fraudulent IP for a legitimate banking website,
<b>www.BankOfSteve.com</b>.  The bad guy's intention is to get all of
the ISP's customers to visit his own malicious site instead of the real
one operated by the Bank.
</p>

<img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/badguy-simple-poison-dns.gif" alt="Simple Poisoning" class="floatRightTop" width="571" height="534">

<ul>
<li>
<b>Step 1</b> — Bad guy sends a DNS query to the victim nameserver
for the hostname it wishes to hijack. This example assumes that the
victim nameserver allows recursive queries from the outside world.
</li>

<li>
<b>Step 2a</b> — Knowing that the victim will shortly be asking
<b>ns1.bankofsteve.com</b> (as directed from the root/GTLD servers)
for an IP address, the bad guy starts flooding the victim with forged
DNS reply packets. All purport to be from ns1.bankofsteve.com, but include the
answer with the IP of badguy's fraudulent webserver.
</li>

<li>
<b>Steps 2b &amp; 3</b> — Root/GTLD servers provide referral to
<b>ns1.bankofsteve.com</b>. This may be multiple queries, but we're
showing just one for simplicity.
</li>

<li>
<b>Step 4</b> — victim nameserver asks <b>ns1.bankofsteve.com</b>
for the IP address of <b>www.bankofsteve.com</b>, and it uses query ID
1001 (one higher than the previous query).
</li>

<li>
<b>Step 5</b> — the real nameserver provides a legitimate response
to this query, with QID=1001. But if the bad guy has successfully matched
the query ID in the step <b>2a</b> flood, this legal reply arrives too
late and is ignored. Oops.
</li>

<li>
<b>Step 6</b> — With the bogus IP address (of the bad guy's webserver)
in cache it provides this poisoned answer to the requesting DNS client. <b>Boom</b>.
</li>

<li>
<b>Step 7</b> (not illustrated) — future DNS clients asking
for <b>www.bankofsteve.com</b> will receive the same fraudulent answer.
</li>
</ul>

<p>
The rule is: <i>first good answer wins</i>. Most of the forged answers are
dropped because the Query ID doesn't match, but if <i>just one</i> in the flurry
of fake responses gets it right, the nameserver will accept the answer as
genuine.
</p>

<p>
And because that satisfies the request, the <i>real</i> answer that arrives
later is dropped, because the query is no longer pending.
</p>

<p>
In any case, once the bad guy gets the answer from the victim's nameserver,
the matter is closed, and he can stop flooding the victim.
</p>

<p>
We'll note that even though this illustrates trying to beat
just the reply from <b>ns1.bankofsteve.com</b>, our forged DNS traffic
could actually match the query ID of <u>any</u> of the prior steps.
</p>

<p>
This includes matching an earlier reply from the root server or the GTLD
(.com) server: if the query ID matches, our fake <u>authoritative</u>
wins, and pollutes the cache. This is a race, but only the attacker knows
it's playing.
</p>


<dl class="defnlist">
<dt> The name can't already be in the cache </dt>
<dd> If <b>www.bankofsteve.com</b> is already in the victim nameserver's
cache, all of the external queries are avoided, and there's simply no
way to poison it in this manner.
</dd>
<dd>
If the bad guy still wants to poison that particular hostname, he has to
wait for it to expire from cache (as determined by the TTL).
</dd>

<dt> The bad guy has to guess the query ID </dt>
<dd> This is made easy with (now-obsolete) nameservers that increment
the Query ID by one each time — even a busy nameserver has a fairly
small range to guess from.
</dd>

<dt> The bad guy has to be faster than the real nameserver </dt>
<dd> If the victim nameserver and the real nameserver are topologically
close (network wise), then the steps 2/3 and 4/5 may complete so
quickly that the bad guy has a too-small window to exploit.
</dd>
</dl>

<h2> Mitigations </h2>


<div class="sidebar">
<center> Is it random? </center>

<p>
Older nameservers used a terrible random number algorithm
that allowed a bad guy to predict the next Query ID given
an existing one, and this was used by attackers to commit
cache poisoning.
</p>

<p>
Modern software uses real random number algorithms that don't
fall for this.
</p>

</div>

<p>
An obvious mitigation here is to <b>randomize the Query ID</b>.
</p>

<p>
With <u>sequential</u> Query IDs, the bad guy has a fairly limited
range of guesses required once he observes a single current Query ID.
If he sees QID=999, then he may flood with QIDs 1000-1029 in an
attempt to make at least one match.
</p>

<p>
Experience has shown this is an easy window to beat.
</p>

<p>
But if the nameserver chooses <u>random</u> Query IDs, then the attacker
has the full 16-bit pool to choose from — that's 64k values —
and this is a much harder target to hit in the narrow window of time
while the victim is going through the routine resolution steps.
</p>

<p>
Though forging 20 packets in routine name-resolution time is straightforward
enough, doing so with <u>thousands</u> of packets is a much more substantial
challenge.
</p>

<p>
So true randomization of Query IDs raises the bar quite a bit.
</p>

<h1 id="shenanigansv2"> Dan's Shenanigans </h1>

<p>
So far we've seen how to poison a single record, but this has less
impact than expected: it's just one record, and many properties require
multiple hostnames to operate, and it's harder to hack them all.
</p>

<p>
Dan Kaminsky found an approach that's dramatically more effective than
this, and it caused quite a furor in the security community. The general
approach is the same as the simple approach shown above, but the key
difference is the nature of the forged payload.
</p>

<img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/badguy-kaminsky-poison-dns.gif" alt="Kaminsky Poisoning" class="floatRightTop" width="571" height="686">

<p>
In the simple example, our intention was to poison the final answer,
the A record with the IP address, but what Dan discovered is that
we can go up one level and <b>hijack the authority records</b> instead.
</p>

<p>
Before undertaking the attack, the bad guy configures a nameserver
that's authoritative for the <b>bankofsteve.com</b> zone, including whatever
resource records he likes: A records, MX for email, etc.
</p>

<p>
There's nothing stopping anybody from configuring his own nameserver
to be authoritative for <i>any</i> domain, but it's pointless because
the root servers won't point to it: it's got answers, but nobody ever
asks it a question.
</p>

<ul>
<li> <b>Step 1</b> — bad guy client requests a <b>random name</b>
within the target domain (<b>www12345678.bankofsteve.com</b>), something
unlikely to be in cache even if other lookups for this domain have been
done recently.
</li>

<li> <p>
<b>Step 2a</b> — As before, the bad guy sends a stream of
forged packets to the victim, but instead of <b>A</b> records as part of
an Answer, it instead delegates to another nameserver via Authority
records. "I don't know the answer, but you can ask over there".
</p>

<p>
The authority data may well contain the "real" <b>bankofsteve.com</b>
nameserver hostnames, but the glue <b>points those nameservers at badguy IPs</b>.
This is the crucial poisoning, because a Query ID match means that the
victim believes that badguy's nameservers are authoritative
for <b>bankofsteve.com</b>.
</p>
<p>
The bad guy now <b>owns the entire zone</b>.
</p>
</li>

<li>
<p>Curiously, the rest of the steps don't matter: the point of this
process was to fake out the victim into thinking that badguy runs
the domain in question, and that would have been successful in this
step.
</p>
<p>
Once one of the victim's queries has been poisoned — it could be
any in the chain — all the rest are directed to badguy's servers.
</p>

</li></ul>

<p>
This is a devastating attack: by owning the entire target
domain, the bad guy controls essentially everything with respect to
that resolving nameserver. He can redirect web visitors to his own
servers (imagine redirecting <b>google.com</b>), he can route email
to his own servers via serving up bogus MX records.
</p>

<p>
The bad guy will typically set a very high TTL in the poisoning
responses so that the victim will keep the bogus data in cache
as long as possible.
</p>

<h2> Flurry of queries </h2>

<p>
Our example has shown a single query being hijacked, but this is
unlikely to be successful: because of Query ID randomization, it's
not likely that that the bad guy will manage to get a hit in the
short time required to match on 64k IDs.
</p>

<p>
Instead, the bad guy issues a flurry of queries, each for a different
random name under the main domain. The <b>first</b> request caused the
nameserver to perform the usual root-first resolution, but it eventually
caches the valid <b>ns1.bankofsteve.com</b> values. Subsequent queries within
this domain go directly to that nameserver, skipping the root steps.
</p>

<p>
But the next request for a different random name (which certainly
won't be in cache) causes an immediate query to the valid <b>ns1</b>
server. The bad guy then throws a flood of forged data at the
victim about that second random name, though the odds here are
still pretty long.
</p>

<p>
Just for the sake of discussion, let's assume that the bad guy can
generate 50 forged replies for each random name query before the
real reply arrives from the real nameserver. This appears to be
a very small chance, but when repeated over and over — and
run from automated tools — success by the bad guy is likely.
</p>

<p>
It's been reported that success can commonly be achieved in 10 seconds.
</p>


<h2> Going for the top </h2>

<p>
Our examples have all focused on hijacking an end domain, but the same
techniques can do the same thing up a level: taking over <b>.COM</b>,
<b>.NET</b>, or the like.
</p>

<p>
By poisoning the Authority records for .COM and the like, the victim
nameserver will route all DNS lookups to the bad guy's nameservers.
This effectively hijacks all names under that top level, including
domains he didn't actually request. This gives a great deal of
flexibility even though it may well require substantial computing
and network resources to serve the flood of requests that this
hijacking must generate.
</p>

<h1 id="fix">What's the fix?</h1>

<p>
This all sounds awful: how does one fix this?
</p>

<p>
As has been alluded to several times, it's the small space — just
16 bits — of the Query ID that makes this attack possible. Though
certainly one might wish to increase that ID to something larger (perhaps
32 bits), it's simply not possible do that in the short term because
it would break DNS on the internet: the fields are what they are, and
they can't be changed casually.
</p>

<div class="sidebar">
<center>DJB Was Right</center>

<p>
One nameserver is notable for having gotten <b>both</b>
the query-id and source-port randomness right from the start:
<a href="http://en.wikipedia.org/wiki/Djbdns">DJBDNS</a>
by the legendary Daniel J. Bernstein.
</p>

<p>
Though long a lightning rod for controversy, he's clearly
walked the walk on security: there's been just
<a href="http://marc.info/?l=djbdns&amp;m=123613000920446&amp;w=2">one
minor security vulnerability</a> in DJBDNS.
</p>

</div>

<p>
But an additional source of randomness is required nevertheless, and
that's been done by <b>randomizing the source port</b>. Rather than use
just a single UDP port, which is trivial to discover, a much larger
range of ports is allocated by the nameserver and then used randomly
when making outbound queries.
</p>

<p>
As one would imagine, the nameserver would keep track of which source
port was used for each query: replies arriving on the wrong port would
be discarded just as if the Query ID failed to match.
</p>

<p>
Microsoft's updated DNS server is said to preallocate 2,500 UDP ports
to use for these random queries, and for discussion we'll round this down
to an even power of two: <b> 2 <sup>11</sup> = 2,048</b>. This yields
this much larger transaction space:
</p>

<img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/dns-trans-entropy.gif" alt="27 bits of entropy" class="leftImage" width="497" height="118">

<p>
Increasing the search space from 64k to 134M provides far better
odds for the good guys.
</p>

<p>
We presume that each nameserver provides a way of setting how large of
a pool to use for these source ports, as well as a way of excluding
certain port numbers known to be required for other purposes.
</p>


<br clear="all">

<h1 id="summary"> Summary </h1>

<p>
This has been an exceptionally serious vulnerability because it undermines
the very faith in DNS: this is at the core of the internet. Most experts
believe that if you can't trust DNS, all else is lost, and we're of this
same mind.
</p>

<p>
There is far more detail about this vulnerability than we can present
here, and we'll urge the reader to consult other resources (especially
<a href="http://www.doxpara.com/DMK_BO2K8.ppt">Dan's presentation</a>).
</p>

<p>
But we can include a few (ahem) random notes about this matter that
didn't seem to fit in elsewhere, and seem important and/or interesting
enough to include in this paper.
</p>

<ul>

<li>
	<i><b>Patch your servers</b></i>: Tools exist to make
	exploit-in-a-box available to even low-skilled bad guys.
</li>

<li>
	Authoritative-only nameservers are not vulnerable because they
	have no cache to poison, but we'd be surprised if no small number
	of "auth only" nameservers actually provided recursive service
	to at least <i>some</i> clients.
</li>

<li>
	A nameserver need not be directly visible to the Internet to
	be exploitable. By convincing a user to visit a particular
	web page, it can trigger a chain of events that reliably
	lead to poisoning.
</li>

<li>
	Even patched servers may still be vulnerable if an intervening
	firewall performs <a href="http://en.wikipedia.org/wiki/Port_address_translation">Port
	Address Translation</a> in a way that un-randomizes the source ports.
</li>

<li>
	It's been suggested that <a href="http://en.wikipedia.org/wiki/DNSSEC">DNSSEC</a>
	or <a href="http://en.wikipedia.org/wiki/Ipv6">IPv6</a> are solutions to
	this problem, but this is only in theory. Both of these technologies
	have to be fully rolled out to be effective, and this is likely
	years away, at best.
</li>

<li>
	The Secure Sockets Layer (SSL) is only a partial protection against
	being redirected to malicious websites. Putting up a fake
	BankOfSteve.com website will have the wrong SSL certificate name
	(which is a warning to the user who's paying attention), but
	the great majority of users skip right through those warnings.
</li>

<li>
	<p>
	But the bad guy can subvert even SSL: since many Certificate Authorities
	validate a user's control over a domain <i>by sending email</i>, hijacking
	a mailserver  by attacking the cert vendor's resolving DNS, this may well
	mean that an attacker can obtain a fully-valid certificate for the target
	domain.
	</p>
	<p>
	This is very scary.
	</p>
</li>

</ul>

<h1 id="refs"> References </h1>

<ul>
<li>
	Dan Kaminsky's <a href="http://www.doxpara.com/DMK_BO2K8.ppt">Black Hat presentation</a>
	(PowerPoint) — Excellent reading.
</li>

<li>
	<a href="http://oreilly.com/catalog/9780596100575/index.html"> DNS and BIND</a>,
	O'Reilly — The definitive book on DNS.
</li>

<li>
	<a href="http://www.amazon.com/TCP-Illustrated-Protocols-Addison-Wesley-Professional/dp/0201633469">TCP/IP Illustrated, Volume 1: The Protocols</a>, W. Richard Stevens — the definitive book
on TCP/IP.
</li>

<li>
	<a href="http://www.isc.org/sw/bind/">BIND (Berkeley Internet Name Domain)</a>
	— The most popular nameserver, with a long history of security issues.
</li>

<li>
	<a href="http://cr.yp.to/djbdns.html">DJBDNS</a> nameserver
	— Always an attitude, but never a security vulnerability.
</li>

<li>
<a href="http://www.mindofroot.com/2008/08/24/episode-63-dns-mess/">Mind Of Root podcast #63</a>
— interviewed regarding the DNS vulnerability
</li>

<li>
<a href="http://en.wikipedia.org/wiki/DNS_cache_poisoning">DNS Cache Poisoning</a> at Wikipedia
</li>

<li>
<img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/made-with-AI.gif" alt="created with Adobe Illustrator" class="floatRightTop" width="172" height="52">
	<a href="http://www.adobe.com/products/illustrator/">Adobe Illustrator CS3</a>™
	— the excellent software used to make the all the diagrams in this paper.
	Yes, this took a <i>long</i> time to write.
<br clear="all">
</li>


</ul>

<hr>

<p>
First published: 2008/08/07
</p>

<div id="navmore">
  <a href="http://unixwiz.net/techtips/index.html"> More Tech Tips </a>
</div>


</div>
<div id="pagefooter">
  <span class="bottomright"> </span>
  <div class="pagefootercontent">
    <a href="http://unixwiz.net/"> Home </a>
	<span class="divbrick"> &nbsp; </span> 
    <a href="http://unixwiz.net/contact.html">Stephen J. Friedl</a>
    <span class="divbrick"> &nbsp;</span>
    Software Consultant
    <span class="divbrick"> &nbsp;</span>
    Orange County, CA USA
    <span class="divbrick"> &nbsp;</span>
    <img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/steve-email.gif" alt="[Steve's Email]">
<span class="divbrick"> &nbsp; </span>
  <a href="http://unixwiz.net/techtips/techtips.rss">
    <img src="An%20Illustrated%20Guide%20to%20the%20Kaminsky%20DNS%20Vulnerability_files/feed-icon-14x14.png" alt="[RSS Feed available]" border="0" width="14" height="14">
  </a>
  </div>
</div>

</body></html>